{"version":3,"sources":["parseLinks.ts"],"names":["emailUserName","schema","domain","port","path","queryString","fragment","emailPattern","schemePrefixedLinkPattern","fqdnLinkPattern","removeMarkdownLinksFromText","input","replace","parseLinksFromText","matches","inputWithoutMarkdownLinks","results","emailRegExp","RegExp","exec","raw","scheme","displayValue","push","encoded","encodeURI","linkRegex","fqdnScheme","fqdnDomainName","fqdnPort","fqdnPath","fqdnQueryStraing","fqdnFragment","schemePrefixedScheme","schemePrefixedPath","join"],"mappings":";;;;;;;;;AAQA,IAAMA,aAAa,GAAG,gBAAtB;AACA,IAAMC,MAAM,uBAAZ;AAEA,IAAMC,MAAM,yFAAZ;AACA,IAAMC,IAAI,kBAAV;AACA,IAAMC,IAAI,wBAAV;AACA,IAAMC,WAAW,kBAAjB;AACA,IAAMC,QAAQ,gBAAd;AAKA,IAAMC,YAAY,sBAAoBP,aAApB,aAAyCE,MAAzC,OAAlB;AAKA,IAAMM,yBAAyB,GAAMP,MAAN,WAA/B;AAMA,IAAMQ,eAAe,GAAMR,MAAN,SAAgBC,MAAhB,GAAyBC,IAAzB,SAAiCC,IAAjC,SAAyCC,WAAzC,SAAwDC,QAAxD,MAArB;;AAYA,IAAMI,2BAA2B,GAAG,SAA9BA,2BAA8B,CAACC,KAAD;AAAA,SAAmBA,KAAK,CAACC,OAAN,CAAc,oBAAd,EAAoC,EAApC,CAAnB;AAAA,CAApC;;AAEO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAACF,KAAD,EAA2B;AAC3D,MAAIG,OAAJ;AAEA,MAAMC,yBAAyB,GAAGL,2BAA2B,CAACC,KAAD,CAA7D;AAEA,MAAMK,OAAe,GAAG,EAAxB;AAEA,MAAMC,WAAW,GAAG,IAAIC,MAAJ,CAAWX,YAAX,EAAyB,IAAzB,CAApB;;AACA,SAAO,CAACO,OAAO,GAAGG,WAAW,CAACE,IAAZ,CAAiBR,KAAjB,CAAX,MAAwC,IAA/C,EAAqD;AACnD,mBAAgDG,OAAhD;AAAA;AAAA,QAAOM,GAAP;AAAA;AAAA,QAAYC,MAAZ,2BAAqB,SAArB;AAAA,QAAgCC,YAAhC;;AACAN,IAAAA,OAAO,CAACO,IAAR,CAAa;AAAEC,MAAAA,OAAO,EAAEC,SAAS,CAACH,YAAD,CAApB;AAAoCF,MAAAA,GAAG,EAAHA,GAApC;AAAyCC,MAAAA,MAAM,EAANA;AAAzC,KAAb;AACD;;AAMD,MAAMK,SAAS,GAAG,IAAIR,MAAJ,CAAcT,eAAd,SAAiCD,yBAAjC,EAA8D,IAA9D,CAAlB;;AACA,SAAO,CAACM,OAAO,GAAGY,SAAS,CAACP,IAAV,CAAeJ,yBAAf,CAAX,MAA0D,IAAjE,EAAuE;AACrE,oBAUID,OAVJ;AAAA;AAAA,QACEM,IADF;AAAA;AAAA,QAEEO,UAFF,2BAEe,EAFf;AAAA;AAAA,QAGEC,cAHF,4BAGmB,EAHnB;AAAA;AAAA,QAIEC,QAJF,4BAIa,EAJb;AAAA;AAAA,QAKEC,QALF,4BAKa,EALb;AAAA;AAAA,QAMEC,gBANF,4BAMqB,EANrB;AAAA;AAAA,QAOEC,YAPF,4BAOiB,EAPjB;AAAA;AAAA,QAQEC,oBARF,4BAQyB,EARzB;AAAA;AAAA,QASEC,kBATF,4BASuB,EATvB;;AAYA,QAAID,oBAAoB,KAAK,EAA7B,EAAiC;AAC/BjB,MAAAA,OAAO,CAACO,IAAR,CAAa;AACXC,QAAAA,OAAO,EAAEC,SAAS,CAACS,kBAAD,CADP;AAEXd,QAAAA,GAAG,EAAHA,IAFW;AAGXC,QAAAA,MAAM,EAAEY;AAHG,OAAb;AAKA;AACD;;AAEDjB,IAAAA,OAAO,CAACO,IAAR,CAAa;AACXC,MAAAA,OAAO,EAAEC,SAAS,CAChB,CAACG,cAAD,EAAiBC,QAAjB,EAA2BC,QAA3B,EAAqCC,gBAArC,EAAuDC,YAAvD,EAAqEG,IAArE,CAA0E,EAA1E,CADgB,CADP;AAIXf,MAAAA,GAAG,EAAHA,IAJW;AAKXC,MAAAA,MAAM,EAAEM;AALG,KAAb;AAOD;;AAED,SAAOX,OAAP;AACD,CAlDM","sourcesContent":["/**\n * ðŸ“£ Note: Do not use named capture groups, as\n *          it is not yet available in Hermes.\n *\n * These helpers indend to make it easier to skim read\n * the patterns below, but note that some are optional,\n * specified in the patterns these are added to.\n * */\nconst emailUserName = '[\\\\w+\\\\.~$_-]+';\nconst schema = `(\\\\w{2,15}:\\\\/\\\\/)`;\n// something.tld OR 123.123.123.123\nconst domain = `((?:\\\\w+\\\\.[a-zA-Z]+)+(?:[^:\\\\/\\\\s]+)|(?:\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}))`;\nconst port = `(:[0-9]{1,5})`;\nconst path = `((?:\\\\/)?[^?#\\\\s]+)`;\nconst queryString = `(\\\\?[^#\\\\s]+)`;\nconst fragment = `(#[\\\\w_-]+)`;\n\n/**\n * Match any email address, with and without `mailto:`\n */\nconst emailPattern = `(mailto:)?((?:${emailUserName})@(?:${domain}))`;\n\n/**\n * Match any string starting with something that seems like it's a schema.\n * */\nconst schemePrefixedLinkPattern = `${schema}(\\\\S+)`;\n\n/**\n * Match as much as possible of a fqdn, at least with a domain name formed as\n * something.tld\n */\nconst fqdnLinkPattern = `${schema}?${domain}${port}?${path}?${queryString}?${fragment}?`;\n\ninterface Link {\n  encoded: string;\n  raw: string;\n  scheme: string;\n}\n\n/**\n * This is done separately because of the version of javascript run\n * for expo\n * */\nconst removeMarkdownLinksFromText = (input: string) => input.replace(/\\[[\\w\\s]+\\]\\(.*\\)/g, '');\n\nexport const parseLinksFromText = (input: string): Link[] => {\n  let matches;\n\n  const inputWithoutMarkdownLinks = removeMarkdownLinksFromText(input);\n\n  const results: Link[] = [];\n\n  const emailRegExp = new RegExp(emailPattern, 'gi');\n  while ((matches = emailRegExp.exec(input)) !== null) {\n    const [raw, scheme = 'mailto:', displayValue] = matches;\n    results.push({ encoded: encodeURI(displayValue), raw, scheme });\n  }\n\n  /**\n   * The two link patterns are checked with an \"or\" (`|`)\n   * to avoid overlapping matches being duplicated in the output.\n   * */\n  const linkRegex = new RegExp(`${fqdnLinkPattern}|${schemePrefixedLinkPattern}`, 'gi');\n  while ((matches = linkRegex.exec(inputWithoutMarkdownLinks)) !== null) {\n    const [\n      raw,\n      fqdnScheme = '',\n      fqdnDomainName = '',\n      fqdnPort = '',\n      fqdnPath = '',\n      fqdnQueryStraing = '',\n      fqdnFragment = '',\n      schemePrefixedScheme = '',\n      schemePrefixedPath = '',\n    ] = matches;\n\n    if (schemePrefixedScheme !== '') {\n      results.push({\n        encoded: encodeURI(schemePrefixedPath),\n        raw,\n        scheme: schemePrefixedScheme,\n      });\n      continue;\n    }\n\n    results.push({\n      encoded: encodeURI(\n        [fqdnDomainName, fqdnPort, fqdnPath, fqdnQueryStraing, fqdnFragment].join(''),\n      ),\n      raw,\n      scheme: fqdnScheme,\n    });\n  }\n\n  return results;\n};\n"]}