{"version":3,"sources":["usePaginatedChannels.ts"],"names":["waitSeconds","seconds","Promise","resolve","setTimeout","ONE_SECOND_IN_MS","DEFAULT_OPTIONS","message_limit","MAX_NUMBER_OF_RETRIES","RETRY_INTERVAL_IN_MS","usePaginatedChannels","filters","options","sort","client","channels","setChannels","activeChannels","error","setError","hasNextPage","setHasNextPage","lastRefresh","Date","now","isQueryingRef","activeQueryType","setActiveQueryType","isMountedRef","filtersRef","sortRef","activeRequestId","queryChannels","queryType","retryCount","current","hasUpdatedData","JSON","stringify","some","Boolean","isQueryStale","currentRequestId","undefined","newOptions","limit","MAX_QUERY_CHANNELS_LIMIT","offset","length","skipInitialization","channelQueryResponse","forEach","channel","state","setIsUpToDate","newChannels","console","warn","Error","loadNextPage","refreshList","reloadList","filterStr","sortStr","loadingChannels","loadingNextPage","refreshing"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nimport type { Channel, ChannelFilters, ChannelOptions, ChannelSort } from 'stream-chat';\n\nimport { useActiveChannelsRefContext } from '../../../contexts/activeChannelsRefContext/ActiveChannelsRefContext';\nimport { useChatContext } from '../../../contexts/chatContext/ChatContext';\nimport { useIsMountedRef } from '../../../hooks/useIsMountedRef';\n\nimport type { DefaultStreamChatGenerics } from '../../../types/types';\nimport { ONE_SECOND_IN_MS } from '../../../utils/date';\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\n\nconst waitSeconds = (seconds: number) =>\n  new Promise((resolve) => {\n    setTimeout(resolve, seconds * ONE_SECOND_IN_MS);\n  });\n\ntype Parameters<StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> =\n  {\n    filters: ChannelFilters<StreamChatGenerics>;\n    options: ChannelOptions;\n    sort: ChannelSort<StreamChatGenerics>;\n  };\n\nconst DEFAULT_OPTIONS = {\n  message_limit: 10,\n};\n\nconst MAX_NUMBER_OF_RETRIES = 3;\nconst RETRY_INTERVAL_IN_MS = 5000;\n\ntype QueryType = 'reload' | 'refresh' | 'loadChannels';\nexport type QueryChannels = (queryType?: QueryType, retryCount?: number) => Promise<void>;\n\nexport const usePaginatedChannels = <\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n>({\n  filters = {},\n  options = DEFAULT_OPTIONS,\n  sort = {},\n}: Parameters<StreamChatGenerics>) => {\n  const { client } = useChatContext<StreamChatGenerics>();\n  const [channels, setChannels] = useState<Channel<StreamChatGenerics>[]>([]);\n  const activeChannels = useActiveChannelsRefContext();\n\n  const [error, setError] = useState<Error>();\n  const [hasNextPage, setHasNextPage] = useState(true);\n  const lastRefresh = useRef(Date.now());\n  const isQueryingRef = useRef(false);\n  const [activeQueryType, setActiveQueryType] = useState<QueryType | null>();\n  const isMountedRef = useIsMountedRef();\n  const filtersRef = useRef<typeof filters | null>(null);\n  const sortRef = useRef<typeof sort | null>(null);\n  const activeRequestId = useRef<number>(0);\n\n  const queryChannels: QueryChannels = async (\n    queryType: QueryType = 'loadChannels',\n    retryCount = 0,\n  ): Promise<void> => {\n    if (!client || !isMountedRef.current) return;\n\n    const hasUpdatedData =\n      queryType === 'loadChannels' ||\n      queryType === 'refresh' ||\n      [\n        JSON.stringify(filtersRef.current) !== JSON.stringify(filters),\n        JSON.stringify(sortRef.current) !== JSON.stringify(sort),\n      ].some(Boolean);\n\n    const isQueryStale = () => !isMountedRef || activeRequestId.current !== currentRequestId;\n\n    /**\n     * We don't need to make another call to query channels if we don't\n     * have new data for the query to include\n     * */\n    if (!hasUpdatedData) {\n      if (activeQueryType === null) return;\n    }\n\n    filtersRef.current = filters;\n    sortRef.current = sort;\n    isQueryingRef.current = true;\n    setError(undefined);\n    activeRequestId.current++;\n    const currentRequestId = activeRequestId.current;\n    setActiveQueryType(queryType);\n\n    const newOptions = {\n      limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n      offset: queryType === 'loadChannels' ? channels.length : 0,\n      ...options,\n    };\n\n    try {\n      const channelQueryResponse = await client.queryChannels(filters, sort, newOptions, {\n        skipInitialization: activeChannels.current,\n      });\n\n      if (isQueryStale() || !isMountedRef.current) {\n        return;\n      }\n\n      channelQueryResponse.forEach((channel) => channel.state.setIsUpToDate(true));\n\n      const newChannels =\n        queryType === 'loadChannels'\n          ? [...channels, ...channelQueryResponse]\n          : channelQueryResponse;\n\n      setChannels(newChannels);\n      setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n      setError(undefined);\n      isQueryingRef.current = false;\n    } catch (err: unknown) {\n      isQueryingRef.current = false;\n      await waitSeconds(2);\n\n      if (isQueryStale()) {\n        return;\n      }\n\n      // querying.current check is needed in order to make sure the next query call doesnt flick an error\n      // state and then succeed (reconnect case)\n      if (retryCount === MAX_NUMBER_OF_RETRIES && !isQueryingRef.current) {\n        setActiveQueryType(null);\n        console.warn(err);\n        setError(\n          new Error(\n            `Maximum number of retries reached in queryChannels. Last error message is: ${err}`,\n          ),\n        );\n        return;\n      }\n\n      return queryChannels(queryType, retryCount + 1);\n    }\n\n    setActiveQueryType(null);\n  };\n\n  const loadNextPage = hasNextPage ? queryChannels : undefined;\n\n  const refreshList = () => {\n    const now = Date.now();\n    // Only allow pull-to-refresh 5 seconds after last successful refresh.\n    if (now - lastRefresh.current < RETRY_INTERVAL_IN_MS && error === undefined) {\n      return;\n    }\n\n    lastRefresh.current = Date.now();\n    return queryChannels('refresh');\n  };\n\n  const reloadList = () => queryChannels('reload');\n\n  /**\n   * Equality check using stringified filters/sort ensure that we don't make un-necessary queryChannels api calls\n   * for the scenario:\n   *\n   * <ChannelList\n   *    filters={{\n   *      members: { $in: ['vishal'] }\n   *    }}\n   *    ...\n   * />\n   *\n   * Here we have passed filters as inline object, which means on every re-render of\n   * parent component, ChannelList will receive new object reference (even though value is same), which\n   * in return will trigger useEffect. To avoid this, we can add a value check.\n   */\n  const filterStr = useMemo(() => JSON.stringify(filters), [filters]);\n  const sortStr = useMemo(() => JSON.stringify(sort), [sort]);\n\n  useEffect(() => {\n    reloadList();\n  }, [filterStr, sortStr]);\n\n  return {\n    channels,\n    error,\n    hasNextPage,\n    loadingChannels: activeQueryType === 'reload',\n    loadingNextPage: activeQueryType === 'loadChannels',\n    loadNextPage,\n    refreshing: activeQueryType === 'refresh',\n    refreshList,\n    reloadList,\n    setChannels,\n  };\n};\n"]}