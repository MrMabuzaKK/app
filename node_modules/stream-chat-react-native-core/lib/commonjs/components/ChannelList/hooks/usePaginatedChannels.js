var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePaginatedChannels = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = require("react");

var _ActiveChannelsRefContext = require("../../../contexts/activeChannelsRefContext/ActiveChannelsRefContext");

var _ChatContext = require("../../../contexts/chatContext/ChatContext");

var _useIsMountedRef = require("../../../hooks/useIsMountedRef");

var _date = require("../../../utils/date");

var _utils = require("../utils");

var waitSeconds = function waitSeconds(seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * _date.ONE_SECOND_IN_MS);
  });
};

var DEFAULT_OPTIONS = {
  message_limit: 10
};
var MAX_NUMBER_OF_RETRIES = 3;
var RETRY_INTERVAL_IN_MS = 5000;

var usePaginatedChannels = function usePaginatedChannels(_ref) {
  var _ref$filters = _ref.filters,
      filters = _ref$filters === void 0 ? {} : _ref$filters,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? DEFAULT_OPTIONS : _ref$options,
      _ref$sort = _ref.sort,
      sort = _ref$sort === void 0 ? {} : _ref$sort;

  var _useChatContext = (0, _ChatContext.useChatContext)(),
      client = _useChatContext.client;

  var _useState = (0, _react.useState)([]),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      channels = _useState2[0],
      setChannels = _useState2[1];

  var activeChannels = (0, _ActiveChannelsRefContext.useActiveChannelsRefContext)();

  var _useState3 = (0, _react.useState)(),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var _useState5 = (0, _react.useState)(true),
      _useState6 = (0, _slicedToArray2["default"])(_useState5, 2),
      hasNextPage = _useState6[0],
      setHasNextPage = _useState6[1];

  var lastRefresh = (0, _react.useRef)(Date.now());
  var isQueryingRef = (0, _react.useRef)(false);

  var _useState7 = (0, _react.useState)(),
      _useState8 = (0, _slicedToArray2["default"])(_useState7, 2),
      activeQueryType = _useState8[0],
      setActiveQueryType = _useState8[1];

  var isMountedRef = (0, _useIsMountedRef.useIsMountedRef)();
  var filtersRef = (0, _react.useRef)(null);
  var sortRef = (0, _react.useRef)(null);
  var activeRequestId = (0, _react.useRef)(0);

  var queryChannels = function () {
    var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
      var _options$limit;

      var queryType,
          retryCount,
          hasUpdatedData,
          isQueryStale,
          currentRequestId,
          newOptions,
          channelQueryResponse,
          newChannels,
          _args = arguments;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              queryType = _args.length > 0 && _args[0] !== undefined ? _args[0] : 'loadChannels';
              retryCount = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;

              if (!(!client || !isMountedRef.current)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return");

            case 4:
              hasUpdatedData = queryType === 'loadChannels' || queryType === 'refresh' || [JSON.stringify(filtersRef.current) !== JSON.stringify(filters), JSON.stringify(sortRef.current) !== JSON.stringify(sort)].some(Boolean);

              isQueryStale = function isQueryStale() {
                return !isMountedRef || activeRequestId.current !== currentRequestId;
              };

              if (hasUpdatedData) {
                _context.next = 9;
                break;
              }

              if (!(activeQueryType === null)) {
                _context.next = 9;
                break;
              }

              return _context.abrupt("return");

            case 9:
              filtersRef.current = filters;
              sortRef.current = sort;
              isQueryingRef.current = true;
              setError(undefined);
              activeRequestId.current++;
              currentRequestId = activeRequestId.current;
              setActiveQueryType(queryType);
              newOptions = (0, _extends2["default"])({
                limit: (_options$limit = options == null ? void 0 : options.limit) != null ? _options$limit : _utils.MAX_QUERY_CHANNELS_LIMIT,
                offset: queryType === 'loadChannels' ? channels.length : 0
              }, options);
              _context.prev = 17;
              _context.next = 20;
              return client.queryChannels(filters, sort, newOptions, {
                skipInitialization: activeChannels.current
              });

            case 20:
              channelQueryResponse = _context.sent;

              if (!(isQueryStale() || !isMountedRef.current)) {
                _context.next = 23;
                break;
              }

              return _context.abrupt("return");

            case 23:
              channelQueryResponse.forEach(function (channel) {
                return channel.state.setIsUpToDate(true);
              });
              newChannels = queryType === 'loadChannels' ? [].concat((0, _toConsumableArray2["default"])(channels), (0, _toConsumableArray2["default"])(channelQueryResponse)) : channelQueryResponse;
              setChannels(newChannels);
              setHasNextPage(channelQueryResponse.length >= newOptions.limit);
              setError(undefined);
              isQueryingRef.current = false;
              _context.next = 44;
              break;

            case 31:
              _context.prev = 31;
              _context.t0 = _context["catch"](17);
              isQueryingRef.current = false;
              _context.next = 36;
              return waitSeconds(2);

            case 36:
              if (!isQueryStale()) {
                _context.next = 38;
                break;
              }

              return _context.abrupt("return");

            case 38:
              if (!(retryCount === MAX_NUMBER_OF_RETRIES && !isQueryingRef.current)) {
                _context.next = 43;
                break;
              }

              setActiveQueryType(null);
              console.warn(_context.t0);
              setError(new Error("Maximum number of retries reached in queryChannels. Last error message is: " + _context.t0));
              return _context.abrupt("return");

            case 43:
              return _context.abrupt("return", queryChannels(queryType, retryCount + 1));

            case 44:
              setActiveQueryType(null);

            case 45:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[17, 31]]);
    }));

    return function queryChannels() {
      return _ref2.apply(this, arguments);
    };
  }();

  var loadNextPage = hasNextPage ? queryChannels : undefined;

  var refreshList = function refreshList() {
    var now = Date.now();

    if (now - lastRefresh.current < RETRY_INTERVAL_IN_MS && error === undefined) {
      return;
    }

    lastRefresh.current = Date.now();
    return queryChannels('refresh');
  };

  var reloadList = function reloadList() {
    return queryChannels('reload');
  };

  var filterStr = (0, _react.useMemo)(function () {
    return JSON.stringify(filters);
  }, [filters]);
  var sortStr = (0, _react.useMemo)(function () {
    return JSON.stringify(sort);
  }, [sort]);
  (0, _react.useEffect)(function () {
    reloadList();
  }, [filterStr, sortStr]);
  return {
    channels: channels,
    error: error,
    hasNextPage: hasNextPage,
    loadingChannels: activeQueryType === 'reload',
    loadingNextPage: activeQueryType === 'loadChannels',
    loadNextPage: loadNextPage,
    refreshing: activeQueryType === 'refresh',
    refreshList: refreshList,
    reloadList: reloadList,
    setChannels: setChannels
  };
};

exports.usePaginatedChannels = usePaginatedChannels;
//# sourceMappingURL=usePaginatedChannels.js.map