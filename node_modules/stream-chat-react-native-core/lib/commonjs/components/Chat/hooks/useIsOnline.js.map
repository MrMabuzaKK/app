{"version":3,"sources":["useIsOnline.ts"],"names":["useIsOnline","client","closeConnectionOnBackground","isOnline","setIsOnline","connectionRecovering","setConnectionRecovering","isMounted","clientExists","onBackground","cid","activeChannels","channel","state","setIsUpToDate","closeConnection","onForeground","openConnection","handleChangedEvent","event","online","handleRecoveredEvent","notifyChatClient","netInfoState","wsConnection","onlineStatusChanged","type","unsubscribeNetInfo","setNetInfoListener","NetInfo","addEventListener","isHealthy","setInitialOnlineState","fetch","status","current","chatListeners","push","on","forEach","listener","unsubscribe"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\n\nimport type { NetInfoSubscription } from '@react-native-community/netinfo';\n\nimport type { StreamChat, Event as StreamEvent } from 'stream-chat';\n\nimport { useAppStateListener } from '../../../hooks/useAppStateListener';\nimport { useIsMountedRef } from '../../../hooks/useIsMountedRef';\nimport { NetInfo } from '../../../native';\n\nimport type { DefaultStreamChatGenerics } from '../../../types/types';\n\n/**\n * Disconnect the websocket connection when app goes to background,\n * and reconnect when app comes to foreground.\n * We do this to make sure the user receives push notifications when app is in the background.\n * You can't receive push notification until you have active websocket connection.\n */\nexport const useIsOnline = <\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n>(\n  client: StreamChat<StreamChatGenerics>,\n  closeConnectionOnBackground = true,\n) => {\n  const [isOnline, setIsOnline] = useState(true);\n  const [connectionRecovering, setConnectionRecovering] = useState(false);\n  const isMounted = useIsMountedRef();\n  const clientExists = !!client;\n\n  const onBackground = useCallback(() => {\n    if (!closeConnectionOnBackground || !clientExists) return;\n\n    for (const cid in client.activeChannels) {\n      const channel = client.activeChannels[cid];\n      channel?.state.setIsUpToDate(false);\n    }\n\n    client.closeConnection();\n    setIsOnline(false);\n  }, [closeConnectionOnBackground, client, clientExists]);\n\n  const onForeground = useCallback(() => {\n    if (!closeConnectionOnBackground || !clientExists) return;\n\n    client.openConnection();\n  }, [closeConnectionOnBackground, client, clientExists]);\n\n  useAppStateListener(onForeground, onBackground);\n\n  useEffect(() => {\n    const handleChangedEvent = (event: StreamEvent<StreamChatGenerics>) => {\n      setConnectionRecovering(!event.online);\n      setIsOnline(event.online || false);\n    };\n\n    const handleRecoveredEvent = () => setConnectionRecovering(false);\n\n    const notifyChatClient = (netInfoState: boolean) => {\n      if (client?.wsConnection) {\n        if (netInfoState) {\n          client.wsConnection.onlineStatusChanged({\n            type: 'online',\n          } as Event);\n        } else {\n          client.wsConnection.onlineStatusChanged({\n            type: 'offline',\n          } as Event);\n        }\n      }\n    };\n\n    let unsubscribeNetInfo: NetInfoSubscription;\n    const setNetInfoListener = () => {\n      unsubscribeNetInfo = NetInfo.addEventListener((netInfoState) => {\n        if (netInfoState === false && !client.wsConnection?.isHealthy) {\n          setConnectionRecovering(true);\n          setIsOnline(false);\n        }\n        notifyChatClient(netInfoState);\n      });\n    };\n\n    const setInitialOnlineState = async () => {\n      const status = await NetInfo.fetch();\n      if (isMounted.current) {\n        setIsOnline(status);\n        notifyChatClient(status);\n      }\n    };\n\n    setInitialOnlineState();\n    const chatListeners: Array<ReturnType<StreamChat['on']>> = [];\n\n    if (client) {\n      chatListeners.push(client.on('connection.changed', handleChangedEvent));\n      chatListeners.push(client.on('connection.recovered', handleRecoveredEvent));\n      setNetInfoListener();\n    }\n\n    return () => {\n      chatListeners.forEach((listener) => listener.unsubscribe?.());\n      unsubscribeNetInfo?.();\n    };\n  }, [clientExists]);\n\n  return { connectionRecovering, isOnline };\n};\n"]}