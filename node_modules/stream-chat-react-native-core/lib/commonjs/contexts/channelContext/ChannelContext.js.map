{"version":3,"sources":["ChannelContext.tsx"],"names":["ChannelContext","React","createContext","DEFAULT_BASE_CONTEXT_VALUE","ChannelProvider","children","value","useChannelContext","contextValue","Error","withChannelContext","Component","WithChannelContextComponent","props","channelContext","displayName"],"mappings":";;;;;;;;;;;AAAA;;AAOA;;AAEA;;AACA;;;;;;;;;AAkKO,IAAMA,cAAc,GAAGC,kBAAMC,aAAN,CAC5BC,mDAD4B,CAAvB;;;;AAIA,IAAMC,eAAe,GAAG,SAAlBA,eAAkB;AAAA,MAG7BC,QAH6B,QAG7BA,QAH6B;AAAA,MAI7BC,KAJ6B,QAI7BA,KAJ6B;AAAA,SAQ7B,gCAAC,cAAD,CAAgB,QAAhB;AAAyB,IAAA,KAAK,EAAEA,KAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGD,QADH,CAR6B;AAAA,CAAxB;;;;AAaA,IAAME,iBAAiB,GAAG,SAApBA,iBAAoB,GAE1B;AACL,MAAMC,YAAY,GAAG,uBACnBR,cADmB,CAArB;;AAIA,MAAIQ,YAAY,KAAKL,mDAAjB,IAA+C,CAAC,2CAApD,EAAyE;AACvE,UAAM,IAAIM,KAAJ,8NAAN;AAGD;;AAED,SAAOD,YAAP;AACD,CAdM;;;;AAoBA,IAAME,kBAAkB,GAAG,SAArBA,kBAAqB,CAIhCC,SAJgC,EAKqC;AACrE,MAAMC,2BAA2B,GAAG,SAA9BA,2BAA8B,CAClCC,KADkC,EAE/B;AACH,QAAMC,cAAc,GAAGP,iBAAiB,EAAxC;AAEA,WAAO,gCAAC,SAAD,gCAAgBM,KAAhB,EAAiCC,cAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAP;AACD,GAND;;AAOAF,EAAAA,2BAA2B,CAACG,WAA5B,0BAA+D,oCAAeJ,SAAf,CAA/D;AACA,SAAOC,2BAAP;AACD,CAfM","sourcesContent":["import React, { PropsWithChildren, useContext } from 'react';\n\nimport type { Channel, ChannelState } from 'stream-chat';\n\nimport type { EmptyStateProps } from '../../components/Indicators/EmptyStateIndicator';\nimport type { LoadingProps } from '../../components/Indicators/LoadingIndicator';\nimport type { DefaultStreamChatGenerics, UnknownType } from '../../types/types';\nimport { DEFAULT_BASE_CONTEXT_VALUE } from '../utils/defaultBaseContextValue';\n\nimport { getDisplayName } from '../utils/getDisplayName';\nimport { isTestEnvironment } from '../utils/isTestEnvironment';\n\nexport type ChannelContextValue<\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n> = {\n  /**\n   * Instance of channel object from stream-chat package.\n   *\n   * Please check the docs around how to create or query channel - https://getstream.io/chat/docs/javascript/creating_channels/?language=javascript\n   *\n   * ```\n   * import { StreamChat, Channel } from 'stream-chat';\n   * import { Chat, Channel} from 'stream-chat-react-native';\n   *\n   * const client = StreamChat.getInstance('api_key');\n   * await client.connectUser('user_id', 'user_token');\n   * const channel = client.channel('messaging', 'channel_id');\n   * await channel.watch();\n   *\n   * <Chat client={client}>\n   *  <Channel channel={channel}>\n   *  </Channel>\n   * </Chat>\n   * ```\n   *\n   * @overrideType Channel\n   */\n  channel: Channel<StreamChatGenerics>;\n  /**\n   * Custom UI component to display empty state when channel has no messages.\n   *\n   * **Default** [EmptyStateIndicator](https://github.com/GetStream/stream-chat-react-native/blob/main/package/src/components/Indicators/EmptyStateIndicator.tsx)\n   */\n  EmptyStateIndicator: React.ComponentType<EmptyStateProps>;\n  /**\n   * When set to true, reactions will be limited to 1 per user. If user selects another reaction\n   * then his previous reaction will be removed and replaced with new one.\n   *\n   * This is similar to reaction UX on [iMessage application](https://en.wikipedia.org/wiki/IMessage).\n   */\n  enforceUniqueReaction: boolean;\n  error: boolean | Error;\n  /**\n   * When set to false, it will disable giphy command on MessageInput component.\n   */\n  giphyEnabled: boolean;\n  /**\n   * Hide inline date separators on channel\n   */\n  hideDateSeparators: boolean;\n  hideStickyDateHeader: boolean;\n  /**\n   * Returns true if the current user has admin privileges\n   */\n  isAdmin: boolean;\n  /**\n   * Returns true if the current user is a moderator\n   */\n  isModerator: boolean;\n  /**\n   * Returns true if the current user is a owner\n   */\n  isOwner: boolean;\n  loadChannelAtMessage: ({\n    after,\n    before,\n    messageId,\n  }: {\n    after?: number;\n    before?: number;\n    messageId?: string;\n  }) => Promise<void>;\n  loading: boolean;\n  /**\n   * Custom loading indicator to override the Stream default\n   */\n  LoadingIndicator: React.ComponentType<LoadingProps>;\n  markRead: () => void;\n  /**\n   *\n   * ```json\n   * {\n   *   \"thierry-123\": {\n   *     \"id\": \"thierry-123\",\n   *     \"role\": \"user\",\n   *     \"created_at\": \"2019-04-03T14:42:47.087869Z\",\n   *     \"updated_at\": \"2019-04-16T09:20:03.982283Z\",\n   *     \"last_active\": \"2019-04-16T11:23:51.168113408+02:00\",\n   *     \"online\": true\n   *   },\n   *   \"vishal-123\": {\n   *     \"id\": \"vishal-123\",\n   *     \"role\": \"user\",\n   *     \"created_at\": \"2019-05-03T14:42:47.087869Z\",\n   *     \"updated_at\": \"2019-05-16T09:20:03.982283Z\",\n   *     \"last_active\": \"2019-06-16T11:23:51.168113408+02:00\",\n   *     \"online\": false\n   *   }\n   * }\n   * ```\n   */\n  members: ChannelState<StreamChatGenerics>['members'];\n  /**\n   * Custom network down indicator to override the Stream default\n   */\n  NetworkDownIndicator: React.ComponentType;\n  read: ChannelState<StreamChatGenerics>['read'];\n  reloadChannel: () => Promise<void>;\n  /**\n   * When true, messagelist will be scrolled to first unread message, when opened.\n   */\n  scrollToFirstUnreadThreshold: number;\n  setLastRead: React.Dispatch<React.SetStateAction<Date | undefined>>;\n  setTargetedMessage: (messageId: string) => void;\n  /**\n   *\n   * ```json\n   * {\n   *   \"thierry-123\": {\n   *     \"id\": \"thierry-123\",\n   *     \"role\": \"user\",\n   *     \"created_at\": \"2019-04-03T14:42:47.087869Z\",\n   *     \"updated_at\": \"2019-04-16T09:20:03.982283Z\",\n   *     \"last_active\": \"2019-04-16T11:23:51.168113408+02:00\",\n   *     \"online\": true\n   *   },\n   *   \"vishal-123\": {\n   *     \"id\": \"vishal-123\",\n   *     \"role\": \"user\",\n   *     \"created_at\": \"2019-05-03T14:42:47.087869Z\",\n   *     \"updated_at\": \"2019-05-16T09:20:03.982283Z\",\n   *     \"last_active\": \"2019-06-16T11:23:51.168113408+02:00\",\n   *     \"online\": false\n   *   }\n   * }\n   * ```\n   */\n  watchers: ChannelState<StreamChatGenerics>['watchers'];\n  disabled?: boolean;\n  enableMessageGroupingByUser?: boolean;\n  isChannelActive?: boolean;\n  lastRead?: Date;\n  /**\n   * Maximum time in milliseconds that should occur between messages\n   * to still consider them grouped together\n   */\n  maxTimeBetweenGroupedMessages?: number;\n  /**\n   * Custom UI component for sticky header of channel.\n   *\n   * **Default** [DateHeader](https://github.com/GetStream/stream-chat-react-native/blob/main/package/src/components/MessageList/DateHeader.tsx)\n   */\n  StickyHeader?: React.ComponentType<{ dateString: string }>;\n  /**\n   * Id of message, around which Channel/MessageList gets loaded when opened.\n   * You will see a highlighted background for targetted message, when opened.\n   */\n  targetedMessage?: string;\n  threadList?: boolean;\n  watcherCount?: ChannelState<StreamChatGenerics>['watcher_count'];\n};\n\nexport const ChannelContext = React.createContext(\n  DEFAULT_BASE_CONTEXT_VALUE as ChannelContextValue,\n);\n\nexport const ChannelProvider = <\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n>({\n  children,\n  value,\n}: PropsWithChildren<{\n  value: ChannelContextValue<StreamChatGenerics>;\n}>) => (\n  <ChannelContext.Provider value={value as unknown as ChannelContextValue}>\n    {children}\n  </ChannelContext.Provider>\n);\n\nexport const useChannelContext = <\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n>() => {\n  const contextValue = useContext(\n    ChannelContext,\n  ) as unknown as ChannelContextValue<StreamChatGenerics>;\n\n  if (contextValue === DEFAULT_BASE_CONTEXT_VALUE && !isTestEnvironment()) {\n    throw new Error(\n      `The useChannelContext hook was called outside of the ChannelContext provider. Make sure you have configured Channel component correctly - https://getstream.io/chat/docs/sdk/reactnative/basics/hello_stream_chat/#channel`,\n    );\n  }\n\n  return contextValue;\n};\n/**\n * Typescript currently does not support partial inference so if ChatContext\n * typing is desired while using the HOC withChannelContext the Props for the\n * wrapped component must be provided as the first generic.\n */\nexport const withChannelContext = <\n  P extends UnknownType,\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n>(\n  Component: React.ComponentType<P>,\n): React.FC<Omit<P, keyof ChannelContextValue<StreamChatGenerics>>> => {\n  const WithChannelContextComponent = (\n    props: Omit<P, keyof ChannelContextValue<StreamChatGenerics>>,\n  ) => {\n    const channelContext = useChannelContext<StreamChatGenerics>();\n\n    return <Component {...(props as P)} {...channelContext} />;\n  };\n  WithChannelContextComponent.displayName = `WithChannelContext${getDisplayName(Component)}`;\n  return WithChannelContextComponent;\n};\n"]}